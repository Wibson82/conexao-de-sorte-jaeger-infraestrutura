name: "üìä Jaeger Infrastructure ‚Äì CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  packages: write
  actions: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  inventory-and-validate:
    name: "üîç Invent√°rio e valida√ß√£o"
    runs-on: [ self-hosted, Linux, X64, conexao, infra, conexao-de-sorte-jaeger-infraestrutura ]
    timeout-minutes: 15
    outputs:
      cache-key: ${{ steps.cache-key.outputs.cache-key }}
      image-ref: ${{ steps.image-metadata.outputs.image-ref }}
      image-tag: ${{ steps.image-metadata.outputs.image-tag }}
      image-digest: ${{ steps.build-image.outputs.digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1
          clean: true

      - name: "üîê Login Azure via OIDC"
        if: >-
          ${{ vars.AZURE_CLIENT_ID != '' && vars.AZURE_TENANT_ID != '' &&
              vars.AZURE_SUBSCRIPTION_ID != '' }}
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: "üìã Validar invent√°rio de segredos"
        shell: bash
        env:
          SERVICE_NAME: jaeger-infrastructure
          KEYVAULT_NAME: ${{ vars.AZURE_KEYVAULT_NAME }}
        run: |
          set -euo pipefail
          echo "Invent√°rio verificado: servi√ßo ${SERVICE_NAME} n√£o requer segredos adicionais neste est√°gio."
          if [[ -n "${KEYVAULT_NAME:-}" ]]; then
            {
              echo "### Invent√°rio de Segredos"
              echo ""
              echo "- Servi√ßo: ${SERVICE_NAME}"
              echo "- Key Vault alvo: ${KEYVAULT_NAME}"
              echo "- Segredos consumidos neste job: nenhum"
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml

      - name: Validate Docker Compose
        run: |
          docker compose -f docker-compose.yml config -q
          echo "‚úÖ Docker Compose syntax is valid"

      - name: Security Validation
        run: |
          if grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "external:"; then
            echo "‚ùå Found potential hardcoded passwords"
            exit 1
          else
            echo "‚úÖ No hardcoded passwords found"
          fi

      - name: "üîß Setup cache key"
        id: cache-key
        run: |
          echo "cache-key=${{ hashFiles('Dockerfile', 'docker-compose.yml') }}" >> "$GITHUB_OUTPUT"

      - name: "üïí Capturar timestamp de build"
        id: build-time
        run: |
          echo "created=$(date -u '+%Y-%m-%dT%H:%M:%SZ')" >> "$GITHUB_OUTPUT"

      - name: "üõ†Ô∏è Configurar Docker Buildx"
        uses: docker/setup-buildx-action@v3
        with:
          install: true

      - name: "üîë Login GHCR"
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: "üìõ Gerar metadados da imagem"
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/jaeger-infrastructure
          tags: |
            type=sha,priority=900
            type=ref,event=branch
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: "üèóÔ∏è Build com cache multi-n√≠vel"
        id: build-image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: ${{ github.event_name != 'pull_request' && github.ref == 'refs/heads/main' }}
          load: ${{ github.event_name == 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha,scope=${{ steps.cache-key.outputs.cache-key }}
            type=local,src=/tmp/.buildx-cache
          cache-to: |
            type=gha,scope=${{ steps.cache-key.outputs.cache-key }},mode=max
            type=local,dest=/tmp/.buildx-cache-new,mode=max
          provenance: false
          build-args: |
            BUILD_SOURCE=https://github.com/${{ github.repository }}
            BUILD_REVISION=${{ github.sha }}
            BUILD_CREATED=${{ steps.build-time.outputs.created }}

      - name: "‚ôªÔ∏è Atualizar cache local Buildx"
        if: always()
        run: |
          if [ -d /tmp/.buildx-cache-new ]; then
            rm -rf /tmp/.buildx-cache || true
            mv /tmp/.buildx-cache-new /tmp/.buildx-cache
          fi

      - name: "üì¶ Registrar refer√™ncia da imagem"
        id: image-metadata
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          set -euo pipefail
          digest="${{ steps.build-image.outputs.digest }}"
          primary_tag=$(printf '%s\n' "$TAGS" | head -n1)
          if [[ -z "$primary_tag" ]]; then
            primary_tag="ghcr.io/${GITHUB_REPOSITORY_OWNER}/jaeger-infrastructure:${GITHUB_SHA}"
          fi
          if [[ -n "$digest" ]]; then
            image_ref="${primary_tag%@*}@${digest}"
          else
            image_ref="$primary_tag"
          fi
          mkdir -p build
          cat <<JSON > build/image-metadata.json
{
  "image_tag": "$primary_tag",
  "image_ref": "$image_ref",
  "digest": "$digest",
  "cache_key": "${{ steps.cache-key.outputs.cache-key }}",
  "build_created": "${{ steps.build-time.outputs.created }}"
}
JSON
          echo "image-tag=$primary_tag" >> "$GITHUB_OUTPUT"
          echo "image-ref=$image_ref" >> "$GITHUB_OUTPUT"
          echo "metadata-path=build/image-metadata.json" >> "$GITHUB_OUTPUT"
          {
            echo "## Imagem constru√≠da"
            echo "- Tag principal: $primary_tag"
            if [[ -n "$digest" ]]; then
              echo "- Digest: $digest"
            fi
            echo "- Chave de cache: ${{ steps.cache-key.outputs.cache-key }}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4.5.0
        with:
          name: jaeger-configs-${{ github.run_id }}
          path: |
            docker-compose.yml
            ${{ steps.image-metadata.outputs.metadata-path }}
          retention-days: 1

  deploy-selfhosted:
    name: "üöÄ Deploy Jaeger"
    needs: inventory-and-validate
    if: github.ref == 'refs/heads/main'
    runs-on: [ self-hosted, Linux, X64, conexao, infra, conexao-de-sorte-jaeger-infraestrutura ]
    timeout-minutes: 15
    env:
      DOCKER_NETWORK_NAME: conexao-network-swarm
      STACK_NAME: conexao-jaeger
      COMPOSE_FILE: docker-compose.yml
      IMAGE_REFERENCE: ${{ needs.inventory-and-validate.outputs.image-ref }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: "üîê Login Azure via OIDC"
        if: >-
          ${{ vars.AZURE_CLIENT_ID != '' && vars.AZURE_TENANT_ID != '' &&
              vars.AZURE_SUBSCRIPTION_ID != '' }}
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: "üîë Carregar segredos necess√°rios do Key Vault"
        if: vars.AZURE_KEYVAULT_NAME != ''
        env:
          KEYVAULT_NAME: ${{ vars.AZURE_KEYVAULT_NAME }}
        shell: bash
        run: |
          set -euo pipefail
          required_secrets=()
          if [[ "${#required_secrets[@]}" -eq 0 ]]; then
            echo "Nenhum segredo do Key Vault √© necess√°rio para este deploy."
            exit 0
          fi

          for secret in "${required_secrets[@]}"; do
            value=$(az keyvault secret show --vault-name "$KEYVAULT_NAME" --name "$secret" --query value -o tsv)
            file_path="$RUNNER_TEMP/$secret"
            printf '%s' "$value" > "$file_path"
            chmod 600 "$file_path"

            case "$secret" in
              swarm-admin-ssh-key)
                echo "SWARM_ADMIN_SSH_KEY_PATH=$file_path" >> "$GITHUB_ENV"
                ;;
              *)
                masked_var=$(echo "$secret" | tr '[:lower:]-' '[:upper:]_')
                echo "${masked_var}_PATH=$file_path" >> "$GITHUB_ENV"
                ;;
            esac
          done

      - name: "üîë Login GHCR"
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download artifacts
        uses: actions/download-artifact@v4.1.8
        with:
          name: jaeger-configs-${{ github.run_id }}
          path: .

      - name: "üöÄ Deploy Jaeger Stack (Swarm-Only)"
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
          COMPOSE_FILE: ${{ env.COMPOSE_FILE }}
          IMAGE_REFERENCE: ${{ env.IMAGE_REFERENCE }}
        run: |
          echo "üöÄ Iniciando deploy do Jaeger com Docker Swarm..."

          jaeger_image="$IMAGE_REFERENCE"
          if [[ -z "$jaeger_image" || "$jaeger_image" == "null" ]]; then
            jaeger_image="jaegertracing/all-in-one:1.60"
          fi
          export JAEGER_IMAGE="$jaeger_image"

          if docker stack ls | grep -q "$STACK_NAME"; then
            echo "üîÑ Removendo stack existente '$STACK_NAME'..."
            docker stack rm "$STACK_NAME"
            sleep 8
          fi

          echo "üèóÔ∏è Executando deploy da stack '$STACK_NAME' com imagem $JAEGER_IMAGE..."
          docker stack deploy -c "$COMPOSE_FILE" "$STACK_NAME"

          echo "‚è∞ Aguardando estabiliza√ß√£o dos servi√ßos Jaeger..."
          sleep 35

      - name: Healthcheck Jaeger (Via Logs)
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
        run: |
          echo "üîç Validando sa√∫de do Jaeger com health checks robustos..."

          timeout=200
          elapsed=0
          health_passed=false

          while [ $elapsed -lt $timeout ] && [ "$health_passed" = false ]; do
            JAEGER_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_jaeger" | head -1)

            if [ -n "$JAEGER_CONTAINER" ]; then
              echo "üîç Testando health check do Jaeger... ($elapsed/$timeout segundos)"

              if docker logs "$JAEGER_CONTAINER" 2>/dev/null | grep -q "Query server started\|Jaeger.*started\|server started.*jaeger"; then
                echo "‚úÖ Jaeger health check passed (logs validation)"
                health_passed=true
                break
              fi

              if docker exec "$JAEGER_CONTAINER" ss -tuln 2>/dev/null | grep -q ":16686 "; then
                echo "‚úÖ Jaeger health check passed (port 16686 active)"
                health_passed=true
                break
              fi

              if docker exec "$JAEGER_CONTAINER" which wget >/dev/null 2>&1; then
                if docker exec "$JAEGER_CONTAINER" wget --quiet --tries=1 --timeout=3 --spider http://localhost:16686 2>/dev/null; then
                  echo "‚úÖ Jaeger health check passed (wget validation)"
                  health_passed=true
                  break
                fi
              fi

              if docker exec "$JAEGER_CONTAINER" ps aux 2>/dev/null | grep -q "[j]aeger\|[q]uery"; then
                echo "‚úÖ Jaeger health check passed (process validation)"
                health_passed=true
                break
              fi

              echo "‚è≥ Jaeger ainda n√£o est√° pronto... ($elapsed/$timeout segundos)"
            else
              echo "‚è≥ Container Jaeger ainda n√£o encontrado... ($elapsed/$timeout segundos)"
            fi

            sleep 10
            elapsed=$((elapsed + 10))
          done

          if [ "$health_passed" = false ]; then
            echo "‚ö†Ô∏è Jaeger health check n√£o passou em $timeout segundos"
            echo "üîç Verificando logs finais do Jaeger..."
            if [ -n "$JAEGER_CONTAINER" ]; then
              echo "--- √öltimos 30 logs do Jaeger ---"
              docker logs "$JAEGER_CONTAINER" --tail 30 2>/dev/null || true
              echo "--- Fim dos logs ---"
            fi
            echo "üí° Nota: Jaeger pode estar funcionando mesmo com health check parcial"
            echo "üí° Verifique os logs acima para diagn√≥stico"
            exit 1
          else
            echo "‚úÖ Jaeger health check conclu√≠do com sucesso!"
          fi

      - name: Connectivity Validation
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
          DOCKER_NETWORK_NAME: ${{ env.DOCKER_NETWORK_NAME }}
        run: |
          echo "üîó Validando conectividade do Jaeger..."

          if docker service ls | grep -q "${STACK_NAME}_jaeger"; then
            echo "‚úÖ Servi√ßo Jaeger encontrado no Swarm"
          else
            echo "‚ùå Servi√ßo Jaeger n√£o encontrado no Swarm"
            exit 1
          fi

          if docker network inspect "$DOCKER_NETWORK_NAME" | grep -q jaeger; then
            echo "‚úÖ Jaeger conectado √† rede overlay"
          else
            echo "‚ö†Ô∏è Jaeger pode n√£o estar na rede overlay correta"
          fi

          JAEGER_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_jaeger" | head -1)
          if [ -n "$JAEGER_CONTAINER" ]; then
            if docker exec "$JAEGER_CONTAINER" ss -tuln 2>/dev/null | grep -q ":9411 "; then
              echo "‚úÖ Jaeger Zipkin endpoint ativo (porta 9411)"
            else
              echo "‚ÑπÔ∏è Jaeger Zipkin endpoint n√£o detectado (pode ser normal)"
            fi
          fi

          echo "üìä Status final dos servi√ßos:"
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

      - name: "üßπ Limpar artefatos tempor√°rios"
        if: always()
        env:
          RUN_ID: ${{ github.run_id }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          api="https://api.github.com/repos/${REPOSITORY}/actions/runs/${RUN_ID}/artifacts"
          response_file=$(mktemp)
          curl -fsS -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" "$api" -o "$response_file"
          mapfile -t artifact_ids < <(ARTIFACT_FILE="$response_file" TARGET_NAME="jaeger-configs-${RUN_ID}" python3 - <<'PY'
import json, os
with open(os.environ["ARTIFACT_FILE"], encoding="utf-8") as handle:
    payload = json.load(handle)
target = os.environ["TARGET_NAME"]
for artifact in payload.get("artifacts", []):
    if artifact.get("name") == target:
        print(str(artifact.get("id")))
PY
          )
          rm -f "$response_file"
          if [[ "${#artifact_ids[@]}" -eq 0 ]]; then
            echo "Nenhum artefato tempor√°rio encontrado para limpeza."
            exit 0
          fi
          for artifact_id in "${artifact_ids[@]}"; do
            delete_url="https://api.github.com/repos/${REPOSITORY}/actions/artifacts/${artifact_id}"
            curl -fsS -X DELETE -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" "$delete_url" >/dev/null && \
              echo "üßπ Artefato ${artifact_id} removido com sucesso."
          done

  ghcr-maintenance:
    name: "üßπ GHCR maintenance"
    needs: deploy-selfhosted
    if: github.ref == 'refs/heads/main'
    runs-on: [ self-hosted, Linux, X64, conexao, infra, conexao-de-sorte-jaeger-infraestrutura ]
    timeout-minutes: 10
    steps:
      - name: "üßπ Limpeza inteligente do GHCR"
        shell: bash
        env:
          SERVICE_NAME: jaeger-infrastructure
          MAX_VERSIONS_TO_KEEP: ${{ vars.MAX_VERSIONS_TO_KEEP || 3 }}
          MAX_AGE_DAYS: ${{ vars.MAX_AGE_DAYS || 7 }}
          PROTECTED_TAGS: ${{ vars.PROTECTED_TAGS || 'latest,main,production' }}
          GHCR_CLEANUP_EXECUTE: ${{ vars.GHCR_CLEANUP_EXECUTE || 'true' }}
        run: |
          set -euo pipefail
          : "${GITHUB_TOKEN:?GITHUB_TOKEN n√£o dispon√≠vel para GHCR cleanup}"

          owner="${GITHUB_REPOSITORY_OWNER}"
          repo_name="${GITHUB_REPOSITORY#*/}"
          default_package=$(echo "$repo_name" | tr '[:upper:]' '[:lower:]')
          service_slug=$(echo "${SERVICE_NAME:-$default_package}" | tr '[:upper:]' '[:lower:]')
          service_slug=${service_slug// /-}
          service_slug=${service_slug//_/-}

          cleanup_ghcr_safe() {
            local package_name="$1"
            local execute_flag="${2:-true}"
            local api="https://api.github.com"
            local accept_header="Accept: application/vnd.github+json"
            local auth_header="Authorization: Bearer ${GITHUB_TOKEN}"
            local scope=""
            local response_file
            response_file="$(mktemp)"

            if curl -fsS -H "$accept_header" -H "$auth_header" \
                "$api/orgs/${owner}/packages/container/${package_name}/versions?per_page=100" \
                -o "$response_file"; then
              scope="orgs/${owner}"
            elif curl -fsS -H "$accept_header" -H "$auth_header" \
                "$api/users/${owner}/packages/container/${package_name}/versions?per_page=100" \
                -o "$response_file"; then
              scope="users/${owner}"
            else
              echo "‚ö†Ô∏è Nenhuma imagem GHCR localizada para ${owner}/${package_name}."
              rm -f "$response_file"
              return 0
            fi

            local plan_file
            plan_file="$(mktemp)"
            trap 'rm -f "$response_file" "$plan_file"' RETURN

            SUMMARY_LOG=$(GHCR_RESPONSE="$response_file" PLAN_FILE="$plan_file" \
              MAX_VERSIONS_TO_KEEP="$MAX_VERSIONS_TO_KEEP" MAX_AGE_DAYS="$MAX_AGE_DAYS" \
              PROTECTED_TAGS="$PROTECTED_TAGS" python3 - <<'PY'
import json, os, sys, datetime
from datetime import datetime, timezone

response_path = os.environ["GHCR_RESPONSE"]
plan_path = os.environ["PLAN_FILE"]
max_versions = int(os.environ.get("MAX_VERSIONS_TO_KEEP") or 3)
max_age_days = int(os.environ.get("MAX_AGE_DAYS") or 7)
protected_raw = os.environ.get("PROTECTED_TAGS", "")
protected_tags = {tag.strip().lower() for tag in protected_raw.split(',') if tag.strip()}

with open(response_path, 'r', encoding='utf-8') as handle:
    try:
        data = json.load(handle)
    except json.JSONDecodeError:
        print("Falha ao decodificar resposta do GHCR", file=sys.stderr)
        json.dump({"delete": [], "summary": {"total": 0}}, open(plan_path, 'w', encoding='utf-8'))
        sys.exit(0)

if isinstance(data, dict):
    versions = data.get("versions", [])
else:
    versions = data

versions = [v for v in versions if isinstance(v, dict)]
versions.sort(key=lambda v: (v.get("updated_at") or v.get("created_at") or ""), reverse=True)

now = datetime.now(timezone.utc)
keep = []
eligible = []

for idx, version in enumerate(versions):
    metadata = (version.get("metadata") or {}).get("container") or {}
    tags = [t for t in (metadata.get("tags") or []) if t]
    tag_set = {t.lower() for t in tags}
    updated_raw = version.get("updated_at") or version.get("created_at")
    if updated_raw:
        updated = datetime.fromisoformat(updated_raw.replace("Z", "+00:00"))
        age_days = max(0, (now - updated).days)
    else:
        age_days = 0
    info = {
        "id": version.get("id"),
        "name": version.get("name"),
        "tags": tags,
        "age_days": age_days,
        "size_bytes": int((metadata.get("image_size") or 0)),
    }
    keep_slot = idx < max_versions
    is_protected = bool(tag_set & protected_tags)
    old_enough = age_days >= max_age_days
    if keep_slot or is_protected or not old_enough:
        keep.append(info)
    else:
        eligible.append(info)

summary = {
    "total": len(versions),
    "kept": len(keep),
    "eligible": len(eligible),
    "max_versions_to_keep": max_versions,
    "max_age_days": max_age_days,
    "protected_tags": sorted(protected_tags),
    "space_reclaimable": sum(item["size_bytes"] for item in eligible),
}

with open(plan_path, 'w', encoding='utf-8') as handle:
    json.dump({"delete": eligible, "summary": summary}, handle, indent=2)

space_mb = summary["space_reclaimable"] / (1024 * 1024) if summary["space_reclaimable"] else 0
lines = [
    f"Total de vers√µes: {summary['total']}",
    f"Mantidas (recentes ou protegidas): {summary['kept']}",
    f"Eleg√≠veis √† remo√ß√£o: {summary['eligible']} (idade ‚â• {max_age_days}d, mantendo {max_versions} vers√µes)",
    f"Espa√ßo potencial a liberar: {space_mb:.2f} MB",
]
if eligible:
    lines.append("Candidatas (limite 10):")
    for item in eligible[:10]:
        tags = ', '.join(item['tags']) if item['tags'] else '<untagged>'
        size_mb_item = item['size_bytes'] / (1024 * 1024) if item['size_bytes'] else 0
        lines.append(f"  - id={item['id']} | tags={tags} | idade={item['age_days']}d | tamanho‚âà{size_mb_item:.2f} MB")

print('\n'.join(lines))
PY
            )

            echo "${SUMMARY_LOG}"
            {
              echo "## GHCR Cleanup"
              echo "$SUMMARY_LOG"
            } >> "$GITHUB_STEP_SUMMARY"

            if [[ "$execute_flag" != "true" ]]; then
              echo "Modo simula√ß√£o habilitado; nenhuma exclus√£o executada."
              return 0
            fi

            mapfile -t targets < <(PLAN_FILE="$plan_file" python3 - <<'PY'
import json, os
plan = json.load(open(os.environ["PLAN_FILE"], encoding='utf-8'))
for item in plan.get("delete", []):
    tags = ','.join(item.get("tags") or []) or '<untagged>'
    size_bytes = item.get("size_bytes") or 0
    print(f"{item['id']}|{item['age_days']}|{tags}|{size_bytes}")
PY
            )

            if [[ "${#targets[@]}" -eq 0 ]]; then
              echo "Nenhuma vers√£o atende aos crit√©rios de limpeza."
              return 0
            fi

            local deleted_count=0
            local reclaimed_bytes=0
            for target in "${targets[@]}"; do
              IFS='|' read -r version_id age_days tag_list size_bytes <<< "$target"
              if [[ -z "$version_id" ]]; then
                continue
              fi
              if curl -fsS -X DELETE -H "$accept_header" -H "$auth_header" \
                  "$api/${scope}/packages/container/${package_name}/versions/${version_id}" >/dev/null; then
                deleted_count=$((deleted_count + 1))
                reclaimed_bytes=$((reclaimed_bytes + size_bytes))
                echo "‚úÖ Removida vers√£o ${version_id} (idade=${age_days}d, tags=${tag_list})"
              else
                echo "‚ö†Ô∏è Falha ao remover vers√£o ${version_id}" >&2
              fi
            done

            local reclaimed_mb
            reclaimed_mb=$(python3 - <<'PY'
import os
size = int(os.environ.get('RECLAIMED_BYTES', '0'))
print(f"{size/1024/1024:.2f}")
PY
              RECLAIMED_BYTES="$reclaimed_bytes")

            {
              echo "### Exclus√µes realizadas"
              echo "- Vers√µes removidas: ${deleted_count}"
              echo "- Espa√ßo liberado (aprox.): ${reclaimed_mb} MB"
            } >> "$GITHUB_STEP_SUMMARY"
          }

          cleanup_ghcr_safe "$service_slug" "$GHCR_CLEANUP_EXECUTE"
