name: "üìä Jaeger Infrastructure ‚Äì CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# Controle de concorr√™ncia para evitar execu√ß√µes simult√¢neas
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Vari√°veis de ambiente global
env:
  SERVICE_NAME: jaeger-infrastructure
  STACK_NAME: conexao-jaeger
  DOCKER_NETWORK_NAME: conexao-network-swarm

permissions:
  id-token: write    # Necess√°rio para OIDC com Azure (azure/login@v2)
  contents: read     # Necess√°rio para checkout em jobs

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      id-token: write
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml jq

      - name: Validate Docker Compose
        run: |
          docker compose -f docker-compose.yml config -q
          echo "‚úÖ Docker Compose syntax is valid"

      - name: Security Validation - No Hardcoded Passwords
        run: |
          # Verificar se n√£o h√° hardcoded passwords
          if grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "external:"; then
            echo "‚ùå Found potential hardcoded passwords"
            exit 1
          else
            echo "‚úÖ No hardcoded passwords found"
          fi

      - name: üîé Validar OIDC Azure
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
          AZURE_KEYVAULT_ENDPOINT: ${{ secrets.AZURE_KEYVAULT_ENDPOINT }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf '‚ùå GitHub Secrets obrigat√≥rios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "‚úÖ Identificadores Azure configurados via secrets"

          # Key Vault √© opcional
          if [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_keyvault=false" >> "$GITHUB_OUTPUT"
          fi

          if [[ -z "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            echo '‚ÑπÔ∏è AZURE_KEYVAULT_ENDPOINT n√£o definido (usando endpoint padr√£o)'
          else
            echo '‚úÖ Endpoint customizado definido'
          fi

          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"

      - name: Validate YAML files
        run: |
          python3 -c "
          import yaml
          import pathlib

          # Validar arquivos YAML principais
          yaml_files = [
              'docker-compose.yml'
          ]

          for file_path in yaml_files:
              if pathlib.Path(file_path).exists():
                  try:
                      with open(file_path, 'r', encoding='utf-8') as f:
                          yaml.safe_load(f)
                      print(f'‚úÖ YAML v√°lido: {file_path}')
                  except Exception as e:
                      print(f'‚ùå Erro no YAML {file_path}: {e}')
                      exit(1)
          "

      - name: ‚úÖ Confirmar consumo m√≠nimo do Key Vault
        if: ${{ steps.check_secrets.outputs.has_keyvault == 'true' }}
        run: |
          echo 'Job de valida√ß√£o n√£o consome segredos do Key Vault (lista vazia).'
          echo "‚úÖ Valida√ß√£o de Key Vault conclu√≠da sem consumo de segredos"

      - name: Validation completed
        run: |
          echo "‚úÖ Valida√ß√£o conclu√≠da - pronto para deploy"

  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [self-hosted, Linux, X64, conexao, conexao-de-sorte-jaeger-infraestrutura]
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: üîê Azure Login (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ‚úÖ Validar conex√£o Azure (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        run: |
          echo "üîç Validando conex√£o com Azure via OIDC..."
          if az account show >/dev/null 2>&1; then
            echo "‚úÖ Conex√£o Azure OIDC estabelecida"
            echo "Subscription: $(az account show --query id -o tsv)"
          else
            echo "‚ùå Falha na conex√£o Azure OIDC"
            exit 1
          fi

      - name: üîí Security Validation - Port Exposure
        run: |
          # Verificar exposi√ß√£o de portas do Jaeger
          if grep -E "^\s*-\s*[\"']?(16686|14268|14269|9411):" docker-compose.yml; then
            echo "‚ö†Ô∏è WARNING: Jaeger ports may be exposed - ensure firewall protection"
            echo "üîí Note: Current configuration works but consider overlay-only for maximum security"
          else
            echo "‚úÖ No ports exposed - maximum security (overlay network only)"
          fi

      - name: ‚úÖ Confirmar consumo m√≠nimo do Key Vault
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        run: |
          echo 'Deploy do Jaeger n√£o consome segredos do Key Vault (lista vazia).'

      - name: üåê Preparar rede overlay compartilhada
        env:
          NETWORK_NAME: ${{ env.DOCKER_NETWORK_NAME }}
        run: |
          set -euo pipefail
          echo "üîç Verificando rede overlay: $NETWORK_NAME"

          if ! docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
            echo "üèóÔ∏è Criando rede overlay compartilhada: $NETWORK_NAME"
            docker network create \
              --driver overlay \
              --attachable \
              --subnet=10.10.0.0/16 \
              --gateway=10.10.0.1 \
              "${NETWORK_NAME}"
            echo "‚úÖ Rede overlay criada: $NETWORK_NAME"
          else
            echo "‚úÖ Rede overlay j√° existe: $NETWORK_NAME"
          fi

      - name: üßπ Cleanup anterior (Jaeger)
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
        run: |
          set -euo pipefail
          echo "üßπ Iniciando limpeza de recursos anteriores..."

          # 1. Graceful shutdown: scale services to 0 replicas
          if docker service ls --filter name="$STACK_NAME" --format '{{.Name}}' | grep -q "^$STACK_NAME"; then
            echo "üîÑ Scaling down servi√ßos do stack $STACK_NAME..."
            for service in $(docker service ls --filter name="$STACK_NAME" --format '{{.Name}}'); do
              echo "  - Scaling down: $service"
              docker service scale "$service=0" >/dev/null 2>&1 || true
            done
            sleep 10
          fi

          # 2. Remove stack
          if docker stack ls --format '{{.Name}}' | grep -q "^$STACK_NAME\$"; then
            echo "üóÑÔ∏è Removendo stack: $STACK_NAME"
            docker stack rm "$STACK_NAME"
            sleep 15
          fi

          # 3. Clean orphan containers
          echo "üßπ Limpando containers √≥rf√£os relacionados ao Jaeger..."
          orphan_containers=$(docker ps -a --filter name="*jaeger*" --format '{{.ID}} {{.Names}}' | grep -E "(jaeger|$STACK_NAME)" || true)
          if [[ -n "$orphan_containers" ]]; then
            echo "$orphan_containers" | while read container_id container_name; do
              if [[ -n "$container_id" ]]; then
                echo "  üóëÔ∏è Removendo container √≥rf√£o: $container_name ($container_id)"
                docker stop "$container_id" >/dev/null 2>&1 || true
                docker rm "$container_id" >/dev/null 2>&1 || true
              fi
            done
          fi

          # 4. Image cleanup (keep 3 recent versions)
          echo "üßπ Limpando imagens antigas do Jaeger (mantendo 3 vers√µes recentes)..."
          old_images=$(docker images --format "{{.ID}} {{.Repository}}:{{.Tag}}" | grep -E "(jaeger|ghcr.io.*jaeger)" | tail -n +4 || true)
          if [[ -n "$old_images" ]]; then
            echo "$old_images" | while read image_id image_tag; do
              if [[ -n "$image_id" && "$image_tag" != *"<none>"* ]]; then
                echo "  üóëÔ∏è Removendo imagem antiga: $image_tag ($image_id)"
                docker rmi "$image_id" >/dev/null 2>&1 || true
              fi
            done
          fi

          echo "‚úÖ Limpeza conclu√≠da"

      - name: üöÄ Deploy Jaeger Stack (Swarm-Only)
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
          COMPOSE_FILE: docker-compose.yml
          JAEGER_VERSION: "2.1.0"
        run: |
          echo "üöÄ Iniciando deploy do Jaeger com Docker Swarm..."

          # Use latest stable Jaeger v2.1.0
          export JAEGER_IMAGE="jaegertracing/jaeger:${JAEGER_VERSION}"
          echo "üì¶ Usando imagem Jaeger: $JAEGER_IMAGE"

          echo "üèóÔ∏è Executando deploy da stack '$STACK_NAME' com Jaeger v$JAEGER_VERSION..."
          docker stack deploy -c "$COMPOSE_FILE" "$STACK_NAME"

          echo "‚è∞ Aguardando estabiliza√ß√£o dos servi√ßos Jaeger..."
          sleep 35

      - name: üîç Healthcheck Jaeger (Via Logs + Port Check)
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
        run: |
          echo "üîç Validando sa√∫de do Jaeger com health checks robustos..."

          timeout=200
          elapsed=0
          health_passed=false

          while [ $elapsed -lt $timeout ] && [ "$health_passed" = false ]; do
            JAEGER_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_jaeger" | head -1)

            if [ -n "$JAEGER_CONTAINER" ]; then
              echo "üîç Testando health check do Jaeger... ($elapsed/$timeout segundos)"

              # Check 1: Process validation
              if docker exec "$JAEGER_CONTAINER" ps aux 2>/dev/null | grep -q "[j]aeger\|[q]uery"; then
                echo "‚úÖ Jaeger health check passed (process validation)"
                health_passed=true
                break
              fi

              # Check 2: Port validation
              if docker exec "$JAEGER_CONTAINER" ss -tuln 2>/dev/null | grep -q ":16686 "; then
                echo "‚úÖ Jaeger health check passed (port 16686 active)"
                health_passed=true
                break
              fi

              # Check 3: Log validation
              if docker logs "$JAEGER_CONTAINER" 2>/dev/null | grep -q "Query server started\|Jaeger.*started\|server started.*jaeger"; then
                echo "‚úÖ Jaeger health check passed (logs validation)"
                health_passed=true
                break
              fi

              # Check 4: HTTP check (if wget available)
              if docker exec "$JAEGER_CONTAINER" which wget >/dev/null 2>&1; then
                if docker exec "$JAEGER_CONTAINER" wget --quiet --tries=1 --timeout=3 --spider http://localhost:16686 2>/dev/null; then
                  echo "‚úÖ Jaeger health check passed (HTTP validation)"
                  health_passed=true
                  break
                fi
              fi

              echo "‚è≥ Jaeger ainda n√£o est√° pronto... ($elapsed/$timeout segundos)"
            else
              echo "‚è≥ Container Jaeger ainda n√£o encontrado... ($elapsed/$timeout segundos)"
            fi

            sleep 10
            elapsed=$((elapsed + 10))
          done

          if [ "$health_passed" = false ]; then
            echo "‚ö†Ô∏è Jaeger health check n√£o passou em $timeout segundos"
            echo "üîç Verificando logs finais do Jaeger..."
            if [ -n "$JAEGER_CONTAINER" ]; then
              echo "--- √öltimos 30 logs do Jaeger ---"
              docker logs "$JAEGER_CONTAINER" --tail 30 2>/dev/null || true
              echo "--- Fim dos logs ---"
            fi
            echo "üí° Nota: Jaeger pode estar funcionando mesmo com health check parcial"
            echo "üí° Verifique os logs acima para diagn√≥stico"
            exit 1
          else
            echo "‚úÖ Jaeger health check conclu√≠do com sucesso!"
          fi

      - name: üîó Connectivity Validation
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
          DOCKER_NETWORK_NAME: ${{ env.DOCKER_NETWORK_NAME }}
        run: |
          echo "üîó Validando conectividade do Jaeger..."

          if docker service ls | grep -q "${STACK_NAME}_jaeger"; then
            echo "‚úÖ Servi√ßo Jaeger encontrado no Swarm"
          else
            echo "‚ùå Servi√ßo Jaeger n√£o encontrado no Swarm"
            exit 1
          fi

          if docker network inspect "$DOCKER_NETWORK_NAME" | grep -q jaeger; then
            echo "‚úÖ Jaeger conectado √† rede overlay"
          else
            echo "‚ö†Ô∏è Jaeger pode n√£o estar na rede overlay correta"
          fi

          JAEGER_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_jaeger" | head -1)
          if [ -n "$JAEGER_CONTAINER" ]; then
            if docker exec "$JAEGER_CONTAINER" ss -tuln 2>/dev/null | grep -q ":9411 "; then
              echo "‚úÖ Jaeger Zipkin endpoint ativo (porta 9411)"
            else
              echo "‚ÑπÔ∏è Jaeger Zipkin endpoint n√£o detectado (pode ser normal)"
            fi
          fi

          echo "üìä Status final dos servi√ßos:"
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

      - name: üßº Limpeza de recursos no servidor
        if: success()
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
        run: |
          set -euo pipefail
          before_usage=$(mktemp)
          after_usage=$(mktemp)
          docker system df > "$before_usage"
          echo "üßπ Removendo containers parados (‚â•12h)..."
          docker container prune -f --filter "until=12h"
          echo "üßπ Removendo imagens n√£o utilizadas (‚â•7d)..."
          docker image prune -f --filter "until=168h"
          echo "üßπ Removendo caches de build antigos (‚â•7d)..."
          docker builder prune -f --filter "until=168h" || true
          docker system df > "$after_usage"
          echo "üì¶ Uso de recursos ap√≥s limpeza:"
          cat "$after_usage"
          {
            echo "## Limpeza de recursos no servidor"
            echo ""
            echo "### Uso antes"
            sed 's/^/    /' "$before_usage"
            echo ""
            echo "### Uso depois"
            sed 's/^/    /' "$after_usage"
          } >> "$GITHUB_STEP_SUMMARY"
          rm -f "$before_usage" "$after_usage"